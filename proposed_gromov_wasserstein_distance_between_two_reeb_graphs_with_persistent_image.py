# -*- coding: utf-8 -*-
"""Prpposed Gromov-Wasserstein distance between two Reeb graphs with Persistent Image.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1USCV6ZVZ9mF3hZ4P3P2k_EKmGsZDC_O4

Install realative python packages
"""

!pip install cereeberus
!pip install networkx gudhi
!pip install POT
!pip install persim
!pip install ripser
!pip install --upgrade scikit-tda

"""## Display two Reeb graphs"""

import cereeberus
import networkx as nx
import matplotlib.pyplot as plt
F = cereeberus.ReebGraph()


F.add_node('f1', f_vertex=24)
F.add_node('f2', f_vertex=18)
F.add_node('f3', f_vertex=20)
F.add_node('f4', f_vertex=12)
F.add_node('f5', f_vertex=15)
F.add_node('f6', f_vertex=6)
F.add_node('f7', f_vertex=8)
F.add_node('f8', f_vertex=2)

F.add_edge('f1', 'f2')
F.add_edge('f2', 'f4')
F.add_edge('f2', 'f5')
F.add_edge('f3', 'f5')
F.add_edge('f5', 'f7')
F.add_edge('f4', 'f6')
F.add_edge('f4', 'f7')
F.add_edge('f7', 'f8')

F.set_pos_from_f(seed = 3)
F.pos_f['f1'] = (0,F.f['f1'])
F.pos_f['f6'] = (-0.3,F.f['f6'])
F.pos_f['f3'] = (0.1,F.f['f3'])
F.pos_f['f5'] = (0.05,F.f['f5'])
F.pos_f['f4'] = (-0.25,F.f['f4'])


# Define custom colors for nodes and edges
node_color = 'skyblue'  # Color for nodes
edge_color = 'gray'     # Color for edges

# Draw the Reeb graph with custom colors
F.draw(cpx=8,with_labels=False)

print(f'Drawing location for f1: {F.pos_f["f1"]}')
print(f'Drawing location for f2: {F.pos_f["f2"]}')
print(f'Drawing location for f3: {F.pos_f["f3"]}')
print(f'Drawing location for f4: {F.pos_f["f4"]}')
print(f'Drawing location for f5: {F.pos_f["f5"]}')
print(f'Drawing location for f6: {F.pos_f["f6"]}')
print(f'Drawing location for f7: {F.pos_f["f7"]}')
print(f'Drawing location for f8: {F.pos_f["f8"]}')


# Manually add labels at desired positions
label_positions = {
    'f1': (0, F.f['f1']),
    'f2': (-0.1146, F.f['f2']),
    'f3': (0.1, F.f['f3']),
    'f4': (-0.25, F.f['f4']),
    'f5': (0.05, F.f['f5']),
    'f6': (-0.3, F.f['f6']),
    'f7': (-0.0988, F.f['f7']),
    'f8': (-0.1370, F.f['f8']),
}

# Add labels to the plot
for node, (x, y) in label_positions.items():
    if node == 'f3':
        plt.text(
            x - 0.02, y, node,  # Position label to the left of 'f3'
            fontsize=18,
            ha='right',  # Align text to the right
            va='center'  # Vertical alignment
        )
    else:
        plt.text(
            x + 0.02, y, node,  # Position labels to the right of other nodes
            fontsize=18,
            ha='left',  # Align text to the left
            va='center'  # Vertical alignment
        )
# plt.axis('on')

# print(f'Drawing location for f5: {F.pos_f["f5"]}')
# print(f'Drawing location for f4: {F.pos_f["f4"]}')
# Add text to the top-right corner
plt.text(
    0.5, 0.95,                # Position (adjust based on your graph layout)
    r"Reeb graph: $R_f$",      # Text content (LaTeX-style math)
    fontsize=22,               # Font size
    horizontalalignment='right',  # Align the text to the right
    verticalalignment='top',      # Align the text to the top
    transform=plt.gca().transAxes  # Relative to the axes
)

plt.savefig('./dancing.jpg', bbox_inches = 'tight')
# plt.savefig('./dancing.eps', format='eps', bbox_inches='tight')

import cereeberus
import networkx as nx
import matplotlib.pyplot as plt

# Create the graph
G = cereeberus.ReebGraph()

# Add nodes with filtration values
G.add_node('g1', f_vertex=24)
G.add_node('g2', f_vertex=20)
G.add_node('g3', f_vertex=18)
G.add_node('g4', f_vertex=16)
G.add_node('g5', f_vertex=12)
G.add_node('g6', f_vertex=8)
G.add_node('g7', f_vertex=6)
G.add_node('g8', f_vertex=4)

# Add edges
G.add_edge('g1', 'g2')
G.add_edge('g2', 'g4')
G.add_edge('g4', 'g3')
G.add_edge('g2', 'g5')
G.add_edge('g4', 'g5')
G.add_edge('g5', 'g6')
G.add_edge('g6', 'g7')
G.add_edge('g6', 'g8')

# Set the node positions
G.pos_f = {
    'g1': (0.2, 24),
    'g2': (0.15, 20),
    'g3': (-0.05, 18),
    'g4': (0, 16),
    'g5': (0.15, 12),
    'g6': (0.15, 8),
    'g7': (0.05, 6),
    'g8': (0.27, 4),
}

# Define custom label positions
label_positions = {
    'g1': (0.25-0.035, 24),  # Slightly right of node g1
    'g2': (0.2-0.035, 20),   # Slightly right of node g2
    'g3': (0.0-0.035, 18),   # Slightly right of node g3
    'g4': (0.05-0.035, 16),  # Slightly right of node g4
    'g5': (0.2-0.035, 12),   # Slightly right of node g5
    'g6': (0.2-0.035, 8),    # Slightly right of node g6
    'g7': (0.1-0.035, 6),    # Slightly right of node g7
    'g8': (0.32-0.08, 4),   # Slightly right of node g8
}

# Draw the graph with the given positions
G.draw(cpx=1, with_labels=False)

# Add labels using the custom label positions
for node, (x, y) in label_positions.items():
    plt.text(
        x, y,            # Use the custom label position
        node,            # Label text
        fontsize=18,
        ha='left',       # Horizontal alignment
        va='center'      # Vertical alignment
    )
# plt.axis('off')
# Add a title or text to the graph
plt.text(
    0.65, 0.95,                # Position (adjust based on your graph layout)
    r"Reeb graph: $R_g$",      # Text content (LaTeX-style math)
    fontsize=22,               # Font size
    horizontalalignment='right',  # Align the text to the right
    verticalalignment='top',      # Align the text to the top
    transform=plt.gca().transAxes  # Relative to the axes
)

# Show the plot
# plt.show()

# Save the plot
plt.savefig('./torus.jpg', bbox_inches='tight')
# plt.savefig('./torus.eps', format='eps', bbox_inches='tight')

"""Three steps to calculate Gromov-Wasserstein disntance between $R_f$ and $R_g$:

Step 1: Compute the Symmetric Reeb Radius.

Step 2: Compute the Persistence Image-Based Borel Probability

Step 3: Identify the Optimal Transport Plan and cal-
culate $GW_p$

##Step 1: Compute the Smoothed Symmetric Reeb Radius.
"""

# Define Graph F
F = nx.Graph()
F_f_values = {'f1': 24, 'f2': 18, 'f3': 20, 'f4': 12, 'f5': 15, 'f6': 6, 'f7': 8, 'f8': 2}
for node, f_val in F_f_values.items():
    F.add_node(node, f_vertex=f_val)
F_edges = [('f1', 'f2'), ('f2', 'f4'), ('f2', 'f5'), ('f3', 'f5'),
           ('f5', 'f7'), ('f4', 'f6'), ('f4', 'f7'), ('f7', 'f8')]
F.add_edges_from(F_edges)

# Define Graph G
G = nx.Graph()
G_f_values = {'g1': 24, 'g2': 20, 'g3': 18, 'g4': 16, 'g5': 12, 'g6': 8, 'g7': 6, 'g8': 4}
for node, f_val in G_f_values.items():
    G.add_node(node, f_vertex=f_val)
G_edges = [('g1', 'g2'), ('g2', 'g4'), ('g4', 'g3'), ('g2', 'g5'),
           ('g4', 'g5'), ('g5', 'g6'), ('g6', 'g7'), ('g6', 'g8')]
G.add_edges_from(G_edges)

## The Reeb Radius algorithm is based on the algorithm 1 from
## Justin's paper: Stability and Approximations for Decorated Reeb Spaces

import heapq
import math
import networkx as nx

def calculate_asymmetric_reeb_radius(graph, g_values, start_node):
    """
    Calculates the asymmetric Reeb radius rho_f(start_node, v) for all nodes v.
    Based on Algorithm 1 from Curry et al. (arXiv:2312.01982v2).

    Args:
      graph: A networkx graph.
      g_values: A dictionary mapping each node to its scalar value f(node).
      start_node: The node x from which to calculate the Reeb radius.

    Returns:
      A dictionary mapping each node v to its asymmetric Reeb radius rho_f(start_node, v).
    """
    reeb_radii = {node: math.inf for node in graph.nodes()}
    reeb_radii[start_node] = 0

    # Priority queue stores tuples: (current_reeb_radius, node)
    priority_queue = [(0, start_node)]

    start_node_value = g_values[start_node]

    while priority_queue:
        current_radius, current_node = heapq.heappop(priority_queue)

        # Optimization: If we found a shorter path already, skip
        # This handles cases where a node might be pushed multiple times
        # before being processed with its final minimum radius.
        if current_radius > reeb_radii[current_node]:
            continue

        for neighbor in graph.neighbors(current_node):
            # Calculate distance in metric space (absolute difference for R)
            # between g(start_node) and g(neighbor)
            dist_start_neighbor = abs(start_node_value - g_values[neighbor])

            # Calculate potential new Reeb radius via current_node
            potential_radius = max(reeb_radii[current_node], dist_start_neighbor)

            # Update ONLY if the neighbor hasn't had its final value set yet
            # (i.e., its value is still infinity), OR if we found a path
            # that has a smaller *maximum deviation*. The standard Dijkstra
            # update (potential_radius < reeb_radii[neighbor]) finds the
            # minimum overall cost path. Here we need the minimum *bottleneck* path.
            # Algorithm 1 in the paper updates only if rho_g(x,w) == infinity.
            # A standard Dijkstra implementation usually checks '<'.
            # Let's stick to the paper's logic for direct implementation:
            # A node's value is set once when it's popped from the queue.
            # We only update neighbors whose values are currently infinity.

            if reeb_radii[neighbor] == math.inf:
                 # Update the radius tentative value
                 reeb_radii[neighbor] = potential_radius
                 heapq.heappush(priority_queue, (potential_radius, neighbor))
            # NOTE: If a node is already in the queue with a higher tentative value,
            # this logic won't update it. However, the Dijkstra property ensures
            # that the first time a node is *popped* from the queue, its radius is final.
            # The check `if current_radius > reeb_radii[current_node]: continue`
            # handles the redundant entries in the queue.

    return reeb_radii

def calculate_symmetric_reeb_radius_matrix(graph, g_values):
    """
    Calculates the full matrix of Symmetric Reeb Radius distances d(u, v)
    for all pairs of nodes (u, v) in the graph.

    Args:
      graph: A networkx graph.
      g_values: A dictionary mapping each node to its scalar value f(node).

    Returns:
      A dictionary of dictionaries representing the symmetric distance matrix.
      matrix[u][v] gives the distance d(u, v).
    """
    nodes = list(graph.nodes())
    num_nodes = len(nodes)
    asymmetric_radii = {}

    # Calculate all asymmetric radii first
    for node in nodes:
        asymmetric_radii[node] = calculate_asymmetric_reeb_radius(graph, g_values, node)

    symmetric_matrix = {u: {v: 0.0 for v in nodes} for u in nodes}

    for i in range(num_nodes):
        for j in range(i, num_nodes): # Iterate through upper triangle including diagonal
            u = nodes[i]
            v = nodes[j]

            rho_uv = asymmetric_radii[u][v]
            rho_vu = asymmetric_radii[v][u]

            # Handle potential infinities if graph is disconnected (shouldn't be here)
            if rho_uv == math.inf or rho_vu == math.inf:
                 symmetric_dist = math.inf
            else:
                 symmetric_dist = 0.5 * (rho_uv + rho_vu)

            symmetric_matrix[u][v] = symmetric_dist
            symmetric_matrix[v][u] = symmetric_dist # Ensure symmetry

    return symmetric_matrix

# --- UPDATED print_matrix function ---
def print_matrix(matrix, title):
    """Prints a matrix (dict of dicts) with aligned columns."""
    print(f"\n--- {title} ---")
    if not matrix:
        print("(Matrix is empty)")
        return

    nodes = sorted(matrix.keys()) # Sort nodes for consistent order
    if not nodes:
        print("(Matrix has no nodes)")
        return

    # Determine column widths
    col_widths = {}
    for v in nodes: # Iterate through columns
        # Width needed for header
        max_width = len(str(v))
        # Width needed for values in this column
        for u in nodes: # Iterate through rows
            # Format value to desired precision first
            formatted_val = f"{matrix[u][v]:.1f}"
            max_width = max(max_width, len(formatted_val))
        col_widths[v] = max_width

    # Determine width for row labels (first column)
    row_label_width = max(len(str(u)) for u in nodes)

    # Print header
    header = f"{' ' * row_label_width} |" # Space for row labels
    for v in nodes:
        header += f" {str(v):>{col_widths[v]}}" # Right-align header in its column width
    print(header)

    # Print separator
    separator = "-" * (row_label_width + 1) + "+" + "-" * (len(header) - row_label_width - 1)
    print(separator)

    # Print rows
    for u in nodes:
        row_str = f"{str(u):>{row_label_width}} |" # Right-align row label
        for v in nodes:
            formatted_val = f"{matrix[u][v]:.1f}"
            row_str += f" {formatted_val:>{col_widths[v]}}" # Right-align value in its column width
        print(row_str)

# Calculate for Graph F
symmetric_matrix_F = calculate_symmetric_reeb_radius_matrix(F, F_f_values)

# Calculate for Graph G
symmetric_matrix_G = calculate_symmetric_reeb_radius_matrix(G, G_f_values)

# Display results with the updated function
print_matrix(symmetric_matrix_F, "Symmetric Reeb Radius Matrix for Graph F")
print_matrix(symmetric_matrix_G, "Symmetric Reeb Radius Matrix for Graph G")

"""## Step 2: Compute the Persistence Image-Based Borel Probability"""

import networkx as nx
import gudhi as gd
import numpy as np
from scipy.stats import multivariate_normal
import matplotlib.pyplot as plt
import warnings

# Suppress specific Gudhi warnings if desired
warnings.filterwarnings("ignore", category=UserWarning, module='gudhi')

def calculate_pi_measure_heuristic_mapping(graph, nx_res=500, ny_res=500, sigma=3, weight_power=1.0, plot_pd=False, plot_pi=False, tolerance=1e-5):
    """
    Calculates Persistence Image based probability measure from a NetworkX graph.
    Uses HEURISTIC node mapping. Plots PD with different markers per type if plot_pd=True.
    # ... (rest of docstring same as before) ...
    """

    print("Starting PI Measure calculation (using heuristic node mapping)...")

    # == Part 1: Calculate Extended Persistence using Gudhi ==
    print("Step 1: Calculating Extended Persistence with Gudhi...")
    node_f_values = nx.get_node_attributes(graph, 'f_vertex')
    if not node_f_values: print("Error: Nodes must have 'f_vertex' attribute."); return None

    # --- (Simplex tree creation remains the same) ---
    node_list = list(graph.nodes())
    node_mapping = {node: idx for idx, node in enumerate(node_list)}
    inverse_node_mapping = {idx: node for node, idx in node_mapping.items()}
    st = gd.SimplexTree()
    node_f_values_mapped = {}
    for node, idx in node_mapping.items(): f_val = node_f_values[node]; st.insert([idx], filtration=f_val); node_f_values_mapped[idx] = f_val
    for u, v in graph.edges(): idx_u, idx_v = node_mapping[u], node_mapping[v]; f_u, f_v = node_f_values_mapped[idx_u], node_f_values_mapped[idx_v]; st.insert([idx_u, idx_v], filtration=max(f_u, f_v))

    # Store pairs by type for plotting, and all finite pairs for PI calc
    pairs_by_type = {"Ordinary": [], "Relative": [], "Extended+": [], "Extended-": []}
    all_finite_pairs_bd = [] # Still needed for PI and mapping

    print("\n--- Raw Gudhi Extended Persistence Output ---")
    try:
        _ = st.make_filtration_non_decreasing(); st.extend_filtration()
        extended_persistence_dgms = st.extended_persistence()
        diagram_types = ["Ordinary", "Relative", "Extended+", "Extended-"]

        if len(extended_persistence_dgms) == len(diagram_types):
             for i, dgm_list in enumerate(extended_persistence_dgms):
                 dgm_type = diagram_types[i]
                 print(f"  Diagram Type: {dgm_type}")
                 if not dgm_list: print("    (empty)"); continue
                 for dim, (birth, death) in dgm_list:
                     birth_str = f"{birth:.3f}" if birth != np.inf else "inf"
                     death_str = f"{death:.3f}" if death != np.inf else "inf"
                     print(f"    Dim {dim}: (Birth={birth_str}, Death={death_str})")
                     # Collect finite pairs for PI calc AND for typed plotting
                     if birth != np.inf and death != np.inf and birth != death:
                         pair = (birth, death)
                         all_finite_pairs_bd.append(pair)
                         if dgm_type in pairs_by_type:
                             pairs_by_type[dgm_type].append(pair)
        else: print("  Warning: Unexpected Gudhi output format."); return None
        print("-------------------------------------------\n")
        print(f"  Collected {len(all_finite_pairs_bd)} total finite pairs for PI.")
        if not all_finite_pairs_bd:
            # ... (Handling for no finite pairs remains the same) ...
             return {'probability_measure': {node: 1.0/len(graph.nodes()) if graph.nodes() else 0 for node in graph.nodes()},
                    'heuristic_mapping': {}, 'persistence_image': np.zeros(nx_res * ny_res),
                    'grid_centers': None, 'birth_range': None, 'persistence_range': None,
                    'finite_pairs_bp': [], 'raw_finite_pairs_bd': [],
                    'message': "No finite persistence pairs found. Returning uniform probability."}
    except Exception as e: print(f"Error during Gudhi calc: {e}"); return None

    # Optional Plotting: Persistence Diagram (Modified for different markers)
    if plot_pd:
        print("  Plotting Persistence Diagram (markers by type)...")
        plt.figure(figsize=(7, 7)) # Adjusted size slightly
        markers = {'Ordinary': 'o', 'Relative': 's', 'Extended+': '^', 'Extended-': 'x'}
        colors = {'Ordinary': 'blue', 'Relative': 'red', 'Extended+': 'green', 'Extended-': 'purple'}
        plotted_types = []

        min_val_plot, max_val_plot = np.inf, -np.inf

        # Plot each type with its marker and color
        for dgm_type, pairs in pairs_by_type.items():
            if pairs:
                pairs_np = np.array(pairs)
                plt.scatter(pairs_np[:, 0], pairs_np[:, 1],
                            label=f'{dgm_type} (n={len(pairs)})',
                            marker=markers.get(dgm_type, 'o'), # Default marker 'o'
                            color=colors.get(dgm_type, 'black'), # Default color black
                            alpha=0.8, s=60) # Increased size slightly
                plotted_types.append(dgm_type)
                # Update plot range based on plotted points
                min_val_plot = min(min_val_plot, np.min(pairs_np))
                max_val_plot = max(max_val_plot, np.max(pairs_np))

        if not plotted_types:
            print("  No finite pairs to plot for PD.")
        else:
            # Add diagonal line and finalize plot
            buffer = abs(max_val_plot - min_val_plot) * 0.05 + 1e-5
            plot_range = [min_val_plot - buffer, max_val_plot + buffer]
            # Adjust diag line calculation in case min/max of birth/death differ significantly
            min_coord = np.min(np.array(all_finite_pairs_bd))
            max_coord = np.max(np.array(all_finite_pairs_bd))
            diag_line = np.linspace(max(plot_range[0], min_coord), min(plot_range[1], max_coord), 10)

            plt.plot(diag_line, diag_line, 'k--', label='Diagonal (y=x)')
            plt.xlabel("Birth")
            plt.ylabel("Death")
            plt.title("Extended Persistence Pairs by Type")
            plt.legend()
            plt.xlim(plot_range)
            plt.ylim(plot_range)
            plt.gca().set_aspect('equal', adjustable='box')
            plt.grid(True)
            plt.show()


    # == Part 1.5: Heuristic Node Mapping ==
    # --- (Remains the same - uses all_finite_pairs_bd) ---
    print("\nStep 1.5: Performing Heuristic Node Mapping...")
    heuristic_mapping = {}
    vertex_to_bp_map = {}
    value_to_nodes = {}
    for node, f_val in node_f_values.items(): value_to_nodes.setdefault(f_val, []).append(node)
    possible_f_values = np.array(list(value_to_nodes.keys()))
    mapping_warnings = 0
    for b, d in all_finite_pairs_bd: # Use the combined list here
        birth_match_indices = np.where(np.isclose(possible_f_values, b, atol=tolerance))[0]
        birth_nodes = [node for idx in birth_match_indices for node in value_to_nodes[possible_f_values[idx]]]
        death_match_indices = np.where(np.isclose(possible_f_values, d, atol=tolerance))[0]
        death_nodes = [node for idx in death_match_indices for node in value_to_nodes[possible_f_values[idx]]]
        heuristic_mapping[(b, d)] = (birth_nodes, death_nodes)
        print(f"  Pair ({b:.3f}, {d:.3f}): Matched BirthNodes={birth_nodes}, DeathNodes={death_nodes}")
        if not birth_nodes or not death_nodes: print(f"    Warning: No match found for b ({b:.3f}) or d ({d:.3f})."); mapping_warnings += 1
        if len(birth_nodes) > 1 or len(death_nodes) > 1: print(f"    Warning: Ambiguous match for b ({b:.3f}) or d ({d:.3f})."); mapping_warnings += 1
        p = abs(d - b); point_bp = (b, p)
        for node in birth_nodes + death_nodes:
             if node in vertex_to_bp_map and vertex_to_bp_map[node] != point_bp:
                 print(f"    Warning: Node {node} re-mapped: {vertex_to_bp_map[node]} -> {point_bp}."); mapping_warnings += 1
             vertex_to_bp_map[node] = point_bp
    if mapping_warnings > 0: print("  Heuristic mapping completed with warnings.")
    else: print("  Heuristic mapping completed.")


    # == Part 2: Calculate Persistence Image ==
    # --- (Remains the same - uses all_finite_pairs_bd) ---
    print("\nStep 2: Calculating Persistence Image...")
    finite_pairs_bp = [(b, abs(d - b)) for b, d in all_finite_pairs_bd] # Use combined list
    weights = [p**weight_power for b, p in finite_pairs_bp]
    # Define grid
    min_b = min(p[0] for p in finite_pairs_bp); max_b = max(p[0] for p in finite_pairs_bp)
    min_p = min(p[1] for p in finite_pairs_bp); max_p = max(p[1] for p in finite_pairs_bp)
    buffer_b = 3 * sigma + (max_b - min_b) * 0.05; buffer_p = 3 * sigma + (max_p - min_p) * 0.05
    birth_range = np.linspace(min_b - buffer_b, max_b + buffer_b, nx_res)
    pers_range = np.linspace(max(0, min_p - buffer_p), max_p + buffer_p, ny_res)
    X, Y = np.meshgrid(birth_range, pers_range); grid_centers = np.array([X.ravel(), Y.ravel()]).T
    # Compute PI
    I_f = np.zeros(nx_res * ny_res)
    print(f"  Generating PI using {len(finite_pairs_bp)} points and sigma={sigma}...")
    for point, weight in zip(finite_pairs_bp, weights): gauss = multivariate_normal(mean=point, cov=sigma**2 * np.eye(2)); I_f += weight * gauss.pdf(grid_centers)
    print("  Persistence Image calculated.")

    # --- (Optional PI Plotting remains the same) ---
    if plot_pi:
         # ... (PI plotting code from previous version) ...
         print("  Plotting Persistence Image...")
         try:
             I_f_2d = I_f.reshape(ny_res, nx_res) # Note reshape order (ny, nx) for imshow
             plt.figure(figsize=(7, 6))
             plt.imshow(I_f_2d, origin='lower', extent=[birth_range[0], birth_range[-1], pers_range[0], pers_range[-1]], cmap='viridis', aspect='auto')
             plt.colorbar(label='Weighted Density')
             used_bp_points = np.array(finite_pairs_bp) # Use the same points for scatter plot
             if used_bp_points.shape[0] > 0: plt.scatter(used_bp_points[:, 0], used_bp_points[:, 1], c='red', s=20, label='(Birth, Persistence) points used in PI')
             plt.xlabel('Birth'); plt.ylabel('Persistence'); plt.title('Persistence Image'); plt.legend(); plt.show()
         except Exception as pi_plot_e: print(f"Warning: Could not plot PI. Error: {pi_plot_e}")


    # == Part 3: Contribution Calculation & Normalization ==
    # --- (Remains the same - uses vertex_to_bp_map) ---
    print("\nStep 3: Calculating Contributions & Normalizing...")
    contributions = {}
    if not vertex_to_bp_map: print("  Warning: No vertices mapped. Assigning uniform probability."); num_nodes = len(graph.nodes()); probability_measure = {node: 1.0/num_nodes if num_nodes > 0 else 0 for node in graph.nodes()}
    else:
         print(f"  Calculating contributions for {len(vertex_to_bp_map)} mapped vertices...")
         for node_id, point_bp in vertex_to_bp_map.items(): b_v, p_v = point_bp; gauss_v = multivariate_normal(mean=[b_v, p_v], cov=sigma**2 * np.eye(2)); contributions[node_id] = np.sum(I_f * gauss_v.pdf(grid_centers))
         for node_id in graph.nodes():
             if node_id not in contributions: contributions[node_id] = 0.0; print(f"  Assigning zero contribution to unmapped node {node_id}.")
         total_contribution = sum(contributions.values()); print(f"  Total contribution Z_f: {total_contribution:.6f}")
         if total_contribution > 1e-9: probability_measure = {node: c / total_contribution for node, c in contributions.items()}; print("  Normalization successful.")
         else: print("  Warning: Total contribution near zero. Assigning uniform probability."); num_nodes = len(graph.nodes()); probability_measure = {node: 1.0/num_nodes if num_nodes > 0 else 0 for node in graph.nodes()}

    message = ("Calculation complete. Probability measure generated using HEURISTIC node mapping. "
               "Verify mapping warnings and results, especially if f_values are non-unique.")
    print(f"\n{message}")

    result = {
        'probability_measure': probability_measure,
        'heuristic_mapping': heuristic_mapping,
        'persistence_image': I_f,
        'grid_centers': grid_centers,
        'birth_range': birth_range,
        'persistence_range': pers_range,
        'finite_pairs_bp': finite_pairs_bp,
        # Removed raw_finite_pairs_bd as it's implicitly stored in pairs_by_type for plotting now
        'message': message
    }
    print("\nFinished.")
    return result

# Run the calculation on F
final_results_F = calculate_pi_measure_heuristic_mapping(F, sigma=2, plot_pd=True, plot_pi=True)

# Print the final probability measure
if final_results_F and 'probability_measure' in final_results_F:
    print("\n--- Final Probability Measure (nu_Rf) ---")
    prob_measure_F = final_results_F['probability_measure']
    for node_id in sorted(prob_measure_F.keys()): print(f"  Node {node_id}: {prob_measure_F[node_id]:.6f}")
    print("-------------------------------------------")

# Run the calculation on G
final_results_G = calculate_pi_measure_heuristic_mapping(G, sigma=2, plot_pd=True, plot_pi=True)

# Print the final probability measure
if final_results_G and 'probability_measure' in final_results_G:
    print("\n--- Final Probability Measure (nu_Rg) ---")
    prob_measure_G = final_results_G['probability_measure']
    for node_id in sorted(prob_measure_G.keys()): print(f"  Node {node_id}: {prob_measure_G[node_id]:.6f}")
    print("-------------------------------------------")
    # print(f"\nMessage: {final_results_G.get('message', 'N/A')}")

import networkx as nx
import gudhi as gd
import numpy as np
from scipy.stats import multivariate_normal
import matplotlib.pyplot as plt
import warnings

# ─────────────────────────────────────────────────────────────────────────────
# Suppress GUDHI warnings
warnings.filterwarnings("ignore", category=UserWarning, module='gudhi')
# ─────────────────────────────────────────────────────────────────────────────

# 1) Global rcParams: boost all font sizes and legend
plt.rcParams.update({
    'figure.titlesize':   22, # Increased
    'axes.titlesize':     20, # Increased
    'axes.labelsize':     18, # Increased
    'xtick.labelsize':    16, # Increased
    'ytick.labelsize':    16, # Increased
    'legend.fontsize':    16, # Increased
    'font.size':          16, # Increased general font size
    'lines.markersize':   10, # Increase default marker size for lines if needed
})

def calculate_pi_measure_heuristic_mapping(
    graph,
    nx_res=500, ny_res=500,
    sigma=5, weight_power=1.0,
    plot_pd=False, plot_pi=False, # These parameters are not used in this specific function
    tolerance=1e-5 # This parameter is not used in this specific function
):
    """
    Computes:
     - pairs_by_type: dict of PD points by diagram type
     - finite_pairs_bp: list of (birth, persistence) for PI
     - persistence_image: flattened array of length nx_res*ny_res
     - birth_range, persistence_range: arrays defining the 2D grid
    """
    node_f_values = nx.get_node_attributes(graph, 'f_vertex')
    if not node_f_values:
        raise RuntimeError("Each node needs an 'f_vertex' attribute")

    # Build simplex tree
    node_list = list(graph.nodes())
    node_mapping = {u: i for i, u in enumerate(node_list)}
    st = gd.SimplexTree()
    for u, i in node_mapping.items():
        st.insert([i], filtration=node_f_values[u])
    for u, v in graph.edges():
        i, j = node_mapping[u], node_mapping[v]
        st.insert([i, j], filtration=max(node_f_values[u], node_f_values[v]))
    st.make_filtration_non_decreasing()
    st.extend_filtration()

    dgms = st.extended_persistence()
    types = ["Ordinary", "Relative", "Extended+", "Extended-"]
    pairs_by_type = {t: [] for t in types}
    all_bd = []
    for t_idx, dgm in enumerate(dgms):
        tname = types[t_idx]
        for dim, (b, d) in dgm:
            # Ensure points are finite and distinct before calculating persistence
            if np.isfinite(b) and np.isfinite(d) and abs(b - d) > tolerance: # Added tolerance for distinctness
                pairs_by_type[tname].append((b, d))
                all_bd.append((b, d))

    # Build persistence‐pairs for PI: (birth, persistence)
    # Ensure all_bd is not empty before proceeding
    if not all_bd:
        # Handle case with no valid persistence pairs (e.g., return empty PI or raise error)
        # For now, let's return empty/default structures to avoid crashing
        return {
            'pd_points':          pairs_by_type,
            'finite_pairs_bp':    [],
            'persistence_image':  np.zeros(nx_res * ny_res),
            'birth_range':        np.linspace(0, 1, nx_res), # Default ranges
            'persistence_range':  np.linspace(0, 1, ny_res), # Default ranges
            'nx_res':             nx_res,
            'ny_res':             ny_res
        }

    finite_pairs_bp = [(b, abs(d - b)) for b, d in all_bd if abs(d-b) > tolerance] # ensure persistence is non-zero

    # Handle cases where finite_pairs_bp might be empty after filtering
    if not finite_pairs_bp:
        return {
            'pd_points':          pairs_by_type,
            'finite_pairs_bp':    [],
            'persistence_image':  np.zeros(nx_res * ny_res),
            'birth_range':        np.linspace(0, 1, nx_res),
            'persistence_range':  np.linspace(0, 1, ny_res),
            'nx_res':             nx_res,
            'ny_res':             ny_res
        }

    weights = [p**weight_power for _, p in finite_pairs_bp if p > tolerance] # ensure weight is for non-zero persistence

    # Filter finite_pairs_bp again to match weights if any p was zero
    finite_pairs_bp = [(b, p) for b, p in finite_pairs_bp if p > tolerance]

    if not finite_pairs_bp: # Check again after filtering by persistence for weights
         return {
            'pd_points':          pairs_by_type,
            'finite_pairs_bp':    [],
            'persistence_image':  np.zeros(nx_res * ny_res),
            'birth_range':        np.linspace(0, 1, nx_res),
            'persistence_range':  np.linspace(0, 1, ny_res),
            'nx_res':             nx_res,
            'ny_res':             ny_res
        }

    # Define grid over birth × persistence
    bs = [b for b, _ in finite_pairs_bp]
    ps = [p for _, p in finite_pairs_bp]
    min_b, max_b = min(bs), max(bs)
    min_p, max_p = min(ps), max(ps) # Persistence should be non-negative

    # Ensure min_p is not negative after buffer for linspace
    actual_min_p = max(0, min_p - (3 * sigma + 0.05 * (max_p - min_p if max_p > min_p else 0))) # ensure buffer logic is safe
    buf_b = 3 * sigma + 0.05 * (max_b - min_b if max_b > min_b else 0) # ensure buffer logic is safe
    buf_p = 3 * sigma + 0.05 * (max_p - min_p if max_p > min_p else 0) # ensure buffer logic is safe

    birth_range = np.linspace(min_b - buf_b, max_b + buf_b, nx_res)
    persistence_range = np.linspace(actual_min_p, max_p + buf_p, ny_res)
    X, Y = np.meshgrid(birth_range, persistence_range)
    grid_centers = np.vstack([X.ravel(), Y.ravel()]).T

    # Compute PI
    I = np.zeros(nx_res * ny_res)
    for (b_val, p_val), w in zip(finite_pairs_bp, weights): # Renamed b_p to b_val, p_val for clarity
        gauss = multivariate_normal(mean=(b_val, p_val), cov=(sigma**2) * np.eye(2))
        I += w * gauss.pdf(grid_centers)

    # Normalize PI if desired (often PI values are used directly)
    # if I.sum() > 0:
    #     I /= I.sum()


    return {
        'pd_points':          pairs_by_type,
        'finite_pairs_bp':    finite_pairs_bp,
        'persistence_image':  I,
        'birth_range':        birth_range,
        'persistence_range':  persistence_range,
        'nx_res':             nx_res,
        'ny_res':             ny_res
    }


def draw_pd(ax, pd_dict):
    """Plot Persistence Diagram by type, with LaTeX labels."""
    # Using LaTeX for labels for consistency with titles
    label_map = {
        'Ordinary':  r'$\mathbf{Ord_0}$',    # Using \mathbf for upright bold math
        'Extended+': r'$\mathbf{Ext_0}$',   # Using \mathbf
        'Relative':  r'$\mathbf{Rel_1}$',   # Using \mathbf
        'Extended-': r'$\mathbf{Ext_1}$'    # Using \mathbf
    }
    markers = {'Ordinary':'o','Relative':'s','Extended+':'^','Extended-':'x'}
    colors  = {'Ordinary':'blue','Relative':'red','Extended+':'green','Extended-':'purple'}

    # Increased marker sizes for PD plot
    marker_size_pd = 150 # Increased from 120

    all_pts_for_bounds = [] # To calculate axis limits correctly
    has_plotted = False

    for t, pairs in pd_dict.items():
        if not pairs:
            continue
        arr = np.array(pairs)
        if arr.size == 0: # Should not happen if pairs is not empty, but as a safeguard
            continue
        all_pts_for_bounds.append(arr)
        ax.scatter(
            arr[:, 0], arr[:, 1],
            label=label_map.get(t, t), # Use raw type name if not in map
            marker=markers.get(t, 'o'), # Default marker
            color=colors.get(t, 'black'), # Default color
            s=marker_size_pd,
            alpha=0.8 # Slightly reduced alpha for better overlap visibility if any
        )
        has_plotted = True

    if has_plotted and all_pts_for_bounds: # Check if any points were actually plotted
        M = np.vstack(all_pts_for_bounds)
        # Handle case where M might be empty or have too few points for min/max
        if M.size > 0:
            mn_val = M.min()
            mx_val = M.max()
            # Ensure mn_val and mx_val are not identical to avoid zero buffer
            if mn_val == mx_val:
                buf = 1.0 # Default buffer if all points are identical
            else:
                buf = 0.05 * (mx_val - mn_val) + 1e-5 # Original buffer logic

            line_min = mn_val - buf
            line_max = mx_val + buf
            ax.plot([line_min, line_max], [line_min, line_max], 'k--', linewidth=2.5) # Increased linewidth
            ax.set_xlim(line_min, line_max)
            ax.set_ylim(line_min, line_max)
        else: # Fallback if M is empty (no finite points)
            ax.plot([0,1], [0,1], 'k--', linewidth=2.5) # Default diagonal
            ax.set_xlim(0,1)
            ax.set_ylim(0,1)


    ax.set_xlabel("Birth") # Font size controlled by rcParams['axes.labelsize']
    ax.set_ylabel("Death") # Font size controlled by rcParams['axes.labelsize']
    ax.set_aspect('equal', 'box')
    if has_plotted: # Only show legend if something was plotted
        ax.legend(loc='best') # Font size controlled by rcParams['legend.fontsize']
    ax.grid(True, linestyle=':')


def draw_pi(ax, res, fig=None):
    """Plot Persistence Image with colorbar."""
    if res['persistence_image'] is None or res['persistence_image'].sum() == 0 : # Check if PI is empty or all zeros
        ax.text(0.5, 0.5, "No finite persistence pairs for PI", horizontalalignment='center', verticalalignment='center', transform=ax.transAxes)
        ax.set_xlabel("Birth")
        ax.set_ylabel("Persistence")
        ax.set_title(ax.get_title()) # Keep original title passed by axs[i,j].set_title()
        return

    I2 = res['persistence_image'].reshape(res['ny_res'], res['nx_res'])
    im = ax.imshow(
        I2,
        origin='lower',
        extent=[
            res['birth_range'][0], res['birth_range'][-1],
            res['persistence_range'][0], res['persistence_range'][-1]
        ],
        aspect='auto', # 'auto' is often better for PIs unless birth/persistence scales are comparable
        cmap='viridis' # 'viridis' is a good default
    )
    if fig is not None:
        cb = fig.colorbar(im, ax=ax, label='Intensity')
        cb.ax.yaxis.label.set_size(plt.rcParams['axes.labelsize']) # Match colorbar label size
        cb.ax.tick_params(labelsize=plt.rcParams['ytick.labelsize']) # Match colorbar tick size


    # overlay birth–persistence points
    if res['finite_pairs_bp']: # Check if there are points to scatter
        ax.scatter(
            [b for b, p_val in res['finite_pairs_bp']], # Renamed p to p_val
            [p_val for _, p_val in res['finite_pairs_bp']], # Renamed p to p_val
            c='red',
            s=100,         # Increased marker size for PI points (was 80)
            edgecolors='black', # Add edgecolors for better visibility
            linewidth=0.5,    # Linewidth for edgecolors
            label=r'(Birth, Persistence)' # CHANGED: LaTeX for legend
        )
    ax.set_xlabel("Birth") # Font size from rcParams
    ax.set_ylabel("Persistence") # Font size from rcParams
    # ax.set_title("Persistence Image") # Title is now set externally
    if res['finite_pairs_bp']: # Only show legend if points were plotted
        ax.legend(loc='best') # Font size from rcParams
    ax.grid(False) # Typically PI plots don't have a grid, but this is preference


# ─────────────────────────────────────────────────────────────────────────────
# Example usage: Define F and G NetworkX graphs first
# This is a placeholder. You need to define your graphs F and G.
# For example:
# F = nx.path_graph(5)
# for i, node in enumerate(F.nodes()):
#     F.nodes[node]['f_vertex'] = float(i)
# G = nx.cycle_graph(6)
# for i, node in enumerate(G.nodes()):
#     G.nodes[node]['f_vertex'] = float(i % 3)
# Replace with your actual graph definitions for F and G
# Make sure F and G have 'f_vertex' attributes for each node.
# ─────────────────────────────────────────────────────────────────────────────

# Create dummy graphs F and G for testing if not defined
if 'F' not in locals() or 'G' not in locals():
    print("INFO: Using dummy graphs F and G for demonstration.")
    F = nx.Graph(name="F_graph")
    F.add_nodes_from(['f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8'])
    # Example 'f_vertex' values (replace with your actuals from the paper example)
    f_values_f = {'f1': 24.0, 'f2': 18.0, 'f3': 20.0, 'f4': 12.0, 'f5': 15.0, 'f6': 6.0, 'f7': 8.0, 'f8': 2.0}
    for node, val in f_values_f.items():
        F.nodes[node]['f_vertex'] = val
    # Add some edges for F to make it a connected graph (example structure)
    F.add_edges_from([('f8','f6'),('f6','f4'),('f4','f7'),('f7','f2'),('f2','f1'),('f2','f5'),('f5','f3')])


    G = nx.Graph(name="G_graph")
    G.add_nodes_from(['g1', 'g2', 'g3', 'g4', 'g5', 'g6', 'g7', 'g8'])
    # Example 'f_vertex' values (replace with your actuals from the paper example)
    f_values_g = {'g1': 24.0, 'g2': 20.0, 'g3': 18.0, 'g4': 16.0, 'g5': 12.0, 'g6': 8.0, 'g7': 6.0, 'g8': 4.0}
    for node, val in f_values_g.items():
        G.nodes[node]['f_vertex'] = val
    # Add some edges for G (example structure)
    G.add_edges_from([('g8','g7'),('g7','g6'),('g6','g5'),('g5','g2'),('g2','g1'),('g5','g4'),('g4','g3')])


# Sigma value from your description (can be tuned)
# The sigma in calculate_pi_measure_heuristic_mapping is the Gaussian kernel std dev
# The sigma in the buffer calculation inside is also this sigma.
# Your provided example had sigma=2 for both.
sigma_val = 2.0 # Adjusted from 5 in function default to 2 as in your call

resF = calculate_pi_measure_heuristic_mapping(F, sigma=sigma_val)
resG = calculate_pi_measure_heuristic_mapping(G, sigma=sigma_val)

# Create the 2x2 subplot
fig, axs = plt.subplots(2, 2, figsize=(16, 14)) # Increased figure size for larger fonts

# F Persistence Diagram
axs[0,0].set_title(r"$R_f$: Extended Persistence") # Using LaTeX for subscript
draw_pd(axs[0,0], resF['pd_points'])

# F Persistence Image
axs[0,1].set_title(r"$R_f$: Persistence Image") # CHANGED: Using LaTeX for subscript
draw_pi(axs[0,1], resF, fig=fig)

# G Persistence Diagram
axs[1,0].set_title(r"$R_g$: Extended Persistence") # Using LaTeX for subscript
draw_pd(axs[1,0], resG['pd_points'])

# G Persistence Image
axs[1,1].set_title(r"$R_g$: Persistence Image") # CHANGED: Using LaTeX for subscript
draw_pi(axs[1,1], resG, fig=fig)

fig.tight_layout(pad=2.0) # Add some padding
plt.show()

# Save high-res PDF if desired
# Consider transparent=True if you overlay it on slides with dark background
fig.savefig("four_panel_PD_PI.pdf", dpi=300, bbox_inches="tight") # Reduced DPI from 1200 to 300 for reasonable file size

"""## Step 3: Identify the Optimal Transport Plan and calculate $GW_p$"""

# ==============================================================
# Step 3: Identify the Optimal Transport Plan and calculate GW
#         Display Transport Matrix as Heatmap (showing zeros)
#         and Plot the results.
# ==============================================================
import ot
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
import matplotlib.colors as mcolors
import matplotlib.cm as cm
import numpy as np # Ensure numpy is imported if not already
import math # For checking infinity

print("\n--- Step 3: GW Calculation, Heatmap Display, and Plotting ---")

# Check if prerequisite variables exist
required_vars = ['F', 'G', 'symmetric_matrix_F', 'symmetric_matrix_G', 'prob_measure_F', 'prob_measure_G']
if not all(var in locals() or var in globals() for var in required_vars):
    print("Error: Prerequisite variables (graphs, matrices, probabilities) not found.")
    print("Please ensure Steps 1 and 2 have run successfully.")
    # Optional: Add dummy data here for testing plotting if needed
    # exit() # Or handle error appropriately
else:
    # --- 3A: Prepare Data for POT ---
    print("  Preparing data for POT library...")

    # Get sorted node lists
    nodes_F = sorted(list(F.nodes()))
    nodes_G = sorted(list(G.nodes()))
    n_F = len(nodes_F)
    n_G = len(nodes_G)

    # Convert distance matrices (dict of dicts) to NumPy arrays C1, C2
    C1 = np.zeros((n_F, n_F), dtype=np.float64)
    for i, u in enumerate(nodes_F):
        for j, v in enumerate(nodes_F):
            dist = symmetric_matrix_F.get(u, {}).get(v, np.inf)
            C1[i, j] = dist if np.isfinite(dist) else np.inf

    C2 = np.zeros((n_G, n_G), dtype=np.float64)
    for i, u in enumerate(nodes_G):
        for j, v in enumerate(nodes_G):
            dist = symmetric_matrix_G.get(u, {}).get(v, np.inf)
            C2[i, j] = dist if np.isfinite(dist) else np.inf

    # Convert probability measures (dicts) to NumPy arrays p, q
    p = np.array([prob_measure_F.get(node, 0.0) for node in nodes_F], dtype=np.float64)
    q = np.array([prob_measure_G.get(node, 0.0) for node in nodes_G], dtype=np.float64)

    # Normalize probabilities
    if n_F > 0:
        p_sum = p.sum()
        if not np.isclose(p_sum, 1.0):
            print(f"  Normalizing p (sum was {p_sum:.4f})")
            if p_sum > 1e-9: p = p / p_sum
            else: p.fill(1.0 / n_F)
    if n_G > 0:
        q_sum = q.sum()
        if not np.isclose(q_sum, 1.0):
            print(f"  Normalizing q (sum was {q_sum:.4f})")
            if q_sum > 1e-9: q = q / q_sum
            else: q.fill(1.0 / n_G)

    # Replace Inf/NaN in C1, C2
    if np.any(~np.isfinite(C1)) or np.any(~np.isfinite(C2)):
         print("  Replacing non-finite values in distance matrices...")
         max_finite_c1 = np.nanmax(C1[np.isfinite(C1)]) if np.any(np.isfinite(C1)) else 0
         max_finite_c2 = np.nanmax(C2[np.isfinite(C2)]) if np.any(np.isfinite(C2)) else 0
         large_val = max(max_finite_c1, max_finite_c2)
         if not np.isfinite(large_val): large_val = 1e12
         large_val = large_val * 10.0 + 1e9
         C1[~np.isfinite(C1)] = large_val
         C2[~np.isfinite(C2)] = large_val

    # --- 3B: Calculate GW Distance and Plan ---
    print("  Calculating GW distance and transport plan...")
    pi = None
    gw_dist = np.inf
    log = {} # Initialize log
    try:
        gw_dist, log = ot.gromov_wasserstein2(
            C1, C2, p, q,
            loss_fun='square_loss',
            log=True, # MUST be True to get 'T'
            verbose=False
            )
        if 'T' in log:
            pi = log['T']
            print(f"--> Calculated GW Distance: {gw_dist:.6f}")
            print(f"  Optimal Transport Plan (pi) shape: {pi.shape}")
        else:
             print(f"--> Calculated GW Distance: {gw_dist:.6f}")
             print("  Warning: Optimal transport plan 'T' not found in POT log.")
             pi = None

    except Exception as e:
        print(f"Error during GW calculation: {e}")
        print("Cannot proceed with plotting or matrix display.")
        pi = None

    # --- Display Transport Matrix as Heatmap ---
    if pi is not None:
        print("\n--- Optimal Transport Plan Heatmap ---")
        fig_hm, ax_hm = plt.subplots(figsize=(8, 7)) # Adjust size as needed

        # Use imshow to display the matrix
        cmap = 'viridis' # Colormap similar to the example
        im = ax_hm.imshow(pi, cmap=cmap, aspect='auto', origin='upper', interpolation='nearest')

        # Add colorbar
        cbar = fig_hm.colorbar(im, ax=ax_hm)
        cbar.set_label('Transported Mass', rotation=270, labelpad=15)

        # Set ticks and labels
        ax_hm.set_xticks(np.arange(n_G))
        ax_hm.set_yticks(np.arange(n_F))
        ax_hm.set_xticklabels(nodes_G)
        ax_hm.set_yticklabels(nodes_F)

        # Rotate the tick labels and set their alignment.
        plt.setp(ax_hm.get_xticklabels(), rotation=45, ha="right",
                 rotation_mode="anchor")

        # Loop over data dimensions and create text annotations FOR ALL CELLS.
        threshold = pi.max() / 2. # Threshold for switching text color (white/black)
        for i in range(n_F):
            for j in range(n_G):
                text_color = "white" if pi[i, j] < threshold else "black"
                # Display value in EVERY cell, formatted to 2 decimal places
                # Values very close to zero (e.g., < 0.005) will display as "0.00"
                text = ax_hm.text(j, i, f"{pi[i, j]:.2f}",
                               ha="center", va="center", color=text_color, fontsize=8) # Adjust fontsize if needed

        ax_hm.set_title("Optimal Transport Plan Heatmap")
        ax_hm.set_xlabel("Nodes in $R_g$ (Target Reeb Graph)")
        ax_hm.set_ylabel("Nodes in $R_f$ (Source Reeb Graph)")
        fig_hm.tight_layout()
        plt.show() # Show the heatmap plot


    # --- Plotting Connections ---
    if pi is not None: # Only plot if GW calculation succeeded
        print("\n  Generating connection plot...")

        # Define Node Positions
        pos_F = {
            'f1': (0, 24), 'f2': (-0.1146, 18), 'f3': (0.1, 20), 'f4': (-0.25, 12),
            'f5': (0.05, 15), 'f6': (-0.3, 6), 'f7': (-0.0988, 8), 'f8': (-0.1370, 2)
        }
        pos_G = {
            'g1': (0.2, 24), 'g2': (0.15, 20), 'g3': (-0.05, 18), 'g4': (0, 16),
            'g5': (0.15, 12), 'g6': (0.15, 8), 'g7': (0.05, 6), 'g8': (0.27, 4)
        }

        # Prepare Layout for Combined Plot
        min_x_F=min(p[0] for p in pos_F.values()); max_x_F=max(p[0] for p in pos_F.values())
        min_x_G=min(p[0] for p in pos_G.values()); max_x_G=max(p[0] for p in pos_G.values())
        x_offset = max_x_F - min_x_G + 0.6
        pos_G_shifted = {node: (pos_G[node][0] + x_offset, pos_G[node][1]) for node in nodes_G if node in pos_G}

        # Create the Plot
        fig_conn, ax_conn = plt.subplots(figsize=(13, 10))

        # Draw Graphs
        nx.draw_networkx_nodes(F, pos_F, node_color='skyblue', node_size=500, ax=ax_conn)
        nx.draw_networkx_edges(F, pos_F, edge_color='blue', width=1.0, alpha=0.7, ax=ax_conn)
        label_offset_F = 0.03
        for node, (x, y) in pos_F.items(): ha = 'right' if node == 'f3' else 'left'; x_adj = x - label_offset_F if node == 'f3' else x + label_offset_F; ax_conn.text(x_adj, y, node, fontsize=12, ha=ha, va='center', color='darkblue')

        nx.draw_networkx_nodes(G, pos_G_shifted, node_color='lightcoral', node_size=500, ax=ax_conn)
        nx.draw_networkx_edges(G, pos_G_shifted, edge_color='red', width=1.0, alpha=0.7, ax=ax_conn)
        label_offset_G = 0.03
        for node, (x, y) in pos_G_shifted.items(): ax_conn.text(x + label_offset_G, y, node, fontsize=12, ha='left', va='center', color='darkred')

        # Draw Connections
        segments = []; pi_values_for_lines = []
        min_pi_for_line = 1e-5
        max_pi_val = pi.max()

        if max_pi_val > 1e-9:
            for i in range(n_F):
                for j in range(n_G):
                    val = pi[i, j]
                    if val >= min_pi_for_line:
                        node_f = nodes_F[i]
                        node_g = nodes_G[j]
                        if node_f in pos_F and node_g in pos_G_shifted:
                            segments.append([pos_F[node_f], pos_G_shifted[node_g]])
                            pi_values_for_lines.append(val)
        else:
            print("    Transport plan seems empty or near zero, skipping connection lines.")

        if segments:
            cmap_conn = plt.get_cmap('Greens')
            norm_vmin = max(min_pi_for_line, 1e-9)
            norm_conn = mcolors.Normalize(vmin=norm_vmin, vmax=max_pi_val)
            line_widths = 0.5 + 2.5 * (np.array(pi_values_for_lines) / max_pi_val)

            lc = LineCollection(segments, cmap=cmap_conn, norm=norm_conn, linewidths=line_widths, linestyle='--', zorder=0, alpha=0.8)
            lc.set_array(np.array(pi_values_for_lines))
            ax_conn.add_collection(lc)

            sm = cm.ScalarMappable(cmap=cmap_conn, norm=norm_conn)
            sm.set_array([])
            cb = plt.colorbar(sm, ax=ax_conn, label='Transported Mass (Connection Strength)', shrink=0.8)
            cb.set_label('Transported Mass (Connection Strength)', fontsize=12)
            cb.ax.tick_params(labelsize=10)
        else:
            print("    No significant transport connections to draw.")

        # Final Plot Adjustments
        ax_conn.set_title("Reeb Graphs F and G with Optimal Transport Plan", fontsize=16)
        ax_conn.set_xlabel("X-coordinate (Shifted for G)")
        ax_conn.set_ylabel("Function Value (f_vertex)")
        plotted_pos = list(pos_F.values()) + list(pos_G_shifted.values())
        if plotted_pos:
            all_x = [p[0] for p in plotted_pos]
            all_y = [p[1] for p in plotted_pos]
            x_buffer = (max(all_x) - min(all_x)) * 0.1 + 0.2
            y_buffer = (max(all_y) - min(all_y)) * 0.05 + 1.0
            ax_conn.set_xlim(min(all_x) - x_buffer, max(all_x) + x_buffer)
            ax_conn.set_ylim(min(all_y) - y_buffer, max(all_y) + y_buffer)
        ax_conn.grid(True, linestyle=':', alpha=0.5)
        fig_conn.tight_layout()
        plt.show()

    else:
        print("\nConnection Plotting skipped as transport plan 'pi' is not available.")

print("\n-----------------------------------------------------")
print("Step 3 Finished.")
print("-----------------------------------------------------")

import ot
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
import matplotlib.colors as mcolors
import matplotlib.cm as cm
import numpy as np
import networkx as nx

# ────────────────────────────────────────────────────────────────
# GLOBAL FONT AND LAYOUT SETTINGS
# ────────────────────────────────────────────────────────────────
plt.rcParams.update({
    "font.size":        22,  # Base font size
    "axes.titlesize":   24,  # Axes title
    "axes.labelsize":   22,  # Axes x/y labels
    "xtick.labelsize":  20,  # Tick labels
    "ytick.labelsize":  20,
    "legend.fontsize":  20,
    "figure.titlesize": 26,
})

print("\n--- Step 3: GW Calculation & Combined Plot ---")

# … assume F, G, symmetric_matrix_F/G, prob_measure_F/G are defined above …

# --- Compute distance matrices C1, C2 and measures p, q (as before) ---
nodes_F = sorted(F.nodes())
nodes_G = sorted(G.nodes())
n_F, n_G = len(nodes_F), len(nodes_G)

# Build C1, C2
C1 = np.array([[np.inf if not np.isfinite(symmetric_matrix_F.get(u,{}).get(v, np.inf))
                else symmetric_matrix_F[u][v]
                for v in nodes_F] for u in nodes_F], dtype=np.float64)
C2 = np.array([[np.inf if not np.isfinite(symmetric_matrix_G.get(u,{}).get(v, np.inf))
                else symmetric_matrix_G[u][v]
                for v in nodes_G] for u in nodes_G], dtype=np.float64)

# Build p, q
p = np.array([prob_measure_F.get(u,0.0) for u in nodes_F], dtype=np.float64)
q = np.array([prob_measure_G.get(u,0.0) for u in nodes_G], dtype=np.float64)
if p.sum()>1e-9: p/=p.sum()
else: p.fill(1.0/n_F)
if q.sum()>1e-9: q/=q.sum()
else: q.fill(1.0/n_G)

# Replace non-finite with a large value
for M in (C1, C2):
    if not np.isfinite(M).all():
        max_f = np.nanmax(M[np.isfinite(M)]) if np.any(np.isfinite(M)) else 0
        large = (max_f if np.isfinite(max_f) else 1e12)*10 + 1e9
        M[~np.isfinite(M)] = large

# --- Compute Gromov–Wasserstein ---
gw_dist, log = ot.gromov_wasserstein2(C1, C2, p, q,
                                     loss_fun='square_loss',
                                     log=True, verbose=False)
pi = log.get('T', None)
if pi is None:
    raise RuntimeError("No transport plan returned.")
print(f"GW distance = {gw_dist:.6f}")

# --- Define node positions for F and G (your layout) ---
pos_F = {
    'f1': (0,24), 'f2':(-0.1146,18), 'f3':(0.1,20), 'f4':(-0.25,12),
    'f5':(0.05,15), 'f6':(-0.3,6), 'f7':(-0.0988,8), 'f8':(-0.1370,2)
}
pos_G = {
    'g1': (0.2,24), 'g2':(0.15,20), 'g3':(-0.05,18), 'g4':(0,16),
    'g5':(0.15,12), 'g6':(0.15,8), 'g7':(0.05,6), 'g8':(0.27,4)
}
# Shift G right of F
min_x_F, max_x_F = min(x for x,y in pos_F.values()), max(x for x,y in pos_F.values())
min_x_G        = min(x for x,y in pos_G.values())
x_offset       = (max_x_F - min_x_G) + 0.6
pos_G_shifted  = {n:(x+x_offset,y) for n,(x,y) in pos_G.items() if n in nodes_G}

# ────────────────────────────────────────────────────────────────
# BUILD FIGURE
# ────────────────────────────────────────────────────────────────
fig, (ax_hm, ax_conn) = plt.subplots(1, 2, figsize=(20, 8))

# Heatmap -------------------------------------------------------
im = ax_hm.imshow(pi, cmap='viridis', origin='upper', aspect='auto')
c1 = fig.colorbar(im, ax=ax_hm, fraction=0.046, pad=0.06)
c1.set_label('Transported Mass', rotation=270, labelpad=20, fontsize=18)
c1.ax.tick_params(labelsize=16)

ax_hm.set_title("Optimal Transport Plan Heatmap", fontsize=20)
ax_hm.set_xlabel("Nodes in $R_g$", fontsize=18)
ax_hm.set_ylabel("Nodes in $R_f$", fontsize=18)
ax_hm.set_xticks(np.arange(n_G))
ax_hm.set_yticks(np.arange(n_F))
ax_hm.set_xticklabels(nodes_G, rotation=45, ha='right', fontsize=16)
ax_hm.set_yticklabels(nodes_F,                fontsize=16)

th = pi.max()/2
for i in range(n_F):
    for j in range(n_G):
        col = 'white' if pi[i,j]<th else 'black'
        ax_hm.text(j, i, f"{pi[i,j]:.2f}",
                   ha='center', va='center',
                   color=col, fontsize=16)

# Connection Plot -----------------------------------------------
# Draw F
nx.draw_networkx_nodes(F, pos_F, node_size=1000, node_color='skyblue', ax=ax_conn)
nx.draw_networkx_edges(F, pos_F, edge_color='blue', width=2.5, ax=ax_conn)
for n,(x,y) in pos_F.items():
    ax_conn.text(x, y, n, fontsize=18, ha='center', va='center', color='darkblue')

# Draw G
nx.draw_networkx_nodes(G, pos_G_shifted, node_size=1000, node_color='lightcoral', ax=ax_conn)
nx.draw_networkx_edges(G, pos_G_shifted, edge_color='red', width=2.5, ax=ax_conn)
for n,(x,y) in pos_G_shifted.items():
    ax_conn.text(x, y, n, fontsize=18, ha='center', va='center', color='darkred')

# Build & trim transport lines ----------------------------------
raw_segs, vals = [], []
for i in range(n_F):
    for j in range(n_G):
        v = pi[i,j]
        if v >= 1e-5:
            nf, ng = nodes_F[i], nodes_G[j]
            if nf in pos_F and ng in pos_G_shifted:
                raw_segs.append((np.array(pos_F[nf]), np.array(pos_G_shifted[ng])))
                vals.append(v)

alpha = 0.05  # trim 5% off each end
segs = []
for p,q in raw_segs:
    vec   = q-p
    start = p + alpha*vec
    end   = q - alpha*vec
    segs.append([tuple(start), tuple(end)])

norm = mcolors.Normalize(vmin=1e-5, vmax=max(vals))
lc = LineCollection(segs, cmap='Greens', norm=norm,
                    linewidths=3.0+5.0*(np.array(vals)/max(vals)),
                    linestyle='--', alpha=0.8)
lc.set_array(np.array(vals))
ax_conn.add_collection(lc)

c2 = fig.colorbar(cm.ScalarMappable(cmap='Greens', norm=norm),
                  ax=ax_conn, fraction=0.046, pad=0.06)
c2.set_label('Transported Mass (Connections)', rotation=270,
             labelpad=20, fontsize=18)
c2.ax.tick_params(labelsize=16)

ax_conn.set_title("Reeb Graphs $R_f$ and $R_g$ with Transport Plan", fontsize=20)
ax_conn.set_ylabel("Function Value", fontsize=18)
ax_conn.set_xlabel("")   # remove x‐label
ax_conn.grid(True, linestyle=':', alpha=0.5)

# tighten and separate
fig.subplots_adjust(left=0.05, right=0.95,
                    bottom=0.05, top=0.90,
                    wspace=0.25)

# Save high‐res PDF
fig.savefig("combined_transport_plan.pdf", dpi=1200,
            format="pdf", bbox_inches="tight")
plt.show()